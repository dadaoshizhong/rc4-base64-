import base64
import numpy as np
import fixedint
import math

# 初始的rc4Key
rc4key = "650f909c-7217-3647-9331-c82df8b98e98"
# base64Chars = "!:#$%&()+-*/`~_[]{}?<>,.@^abcdefghijklmnopqrstuvwxyz0123456789\';"
base64table = "!:#$%&()+-*/`~_[]{}?<>,.@^abcdefghijklmnopqrstuvwxyz0123456789\\';"
std_base64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="

# 密码争取加密后的结果
# 0x7b,0x39,0x2a,0x38,0x67,0x61,0x2a,0x6c,0x21,0x54,0x6e,0x3f,
# 0x40,0x23,0x66,0x6a,0x27,0x6a,0x24,0x5c,0x5c,0x67,0x3b,0x3b
encode_flag = " {9*8ga*l!Tn?@#fj'j$\g;;"

# RC4密钥去掉-
# return 650f909c721736479331c82df8b98e98
def getRc4Key2():
    rc4key2 = ""
    for i in range(len(rc4key)):
        value = rc4key[i]
        if ( ord(value) != 0x2d): # 字符串 转 ascii码
            rc4key2 += value
    return rc4key2

# return 89e89b8f-d28c-1339-7463-7127c909f056
def getRc4Key3(key):
    keylen = len(key)
    rc4key2value1 = 0xFFFFFFF8
    rc4key2value2 = 0x0
    rc4key3 = ""

    while keylen > 0:
        temp = rc4key2value1 >> 2
        temp2 = rc4key2value2 | temp
        if temp2 <= 3:
            rc4key3 += chr(0x2d)# ascii码 转  字符串

        keylen -= 1
        rc4key3 += key[keylen]

        rc4key2value2 += 0x40000000
        rc4key2value2 = fixedint.UInt32(rc4key2value2)
        rc4key2value1 += 1
        rc4key2value1 = fixedint.UInt32(rc4key2value1)

    return rc4key3

#     算法参数01：unk_23DE(10位长度) =2409715836
#     算法参数02：unk_23D8（16位长度）=dbeafc2409715836
# return 36f36b3c-a03e-4996-8759-8408e626c215
def getRc4Key4(key):
    keylen = len(key)
    keypos = 0
    retnkey = ""
    unk_23DE = "2409715836"
    unk_23D8 = "dbeafc2409715836"

    while keylen > 0:
        value = key[keypos]
        valueascii = ord(value)
        value97 = valueascii - 97
        value48 = valueascii - 48
        if (value97 <= 5) and (value97 >= 0):
            value = unk_23D8[value97]
        elif (value48 <= 9) and (value48 >= 0):
            value = unk_23DE[value48]

        retnkey += value
        keylen -= 1
        keypos += 1

    return retnkey

# 根据密钥生成临时的数据key
# 计算RC4 的临时256自己T向量，公式：iK[i]=(byte)aKey.charAt((i % aKey.length()));
# retn =
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f36b3c-a03e-4996-8759-8408e626c215
#     36f3
def getRc4Key5(key):
    tbox = ""
    pos = 0
    keylen = len(key)

    while pos < 256:
        tbox += key[pos % keylen]
        pos += 1

    return tbox

# 依据K将S-Box乱序
# retn = sbox =
# [0xf0,0x37,0xe1,0x9b,0x2a,0x15,0x17,0x9f,0xd7,0x58,0x4d,0x6e,0x33,0xa0,0x39,0xae,0x4,0xd0,
# 0xbe,0xed,0xf8,0x66,0x5e,0x0,0xd6,0x91,0x2f,0xc3,0x10,0x4c,0xf7,0xa6,0xc1,0xec,0x6d,0xb,
# 0x50,0x65,0xbb,0x34,0xfa,0xa4,0x2d,0x3b,0x23,0xa1,0x96,0xd5,0x1d,0x38,0x56,0xa,0x5d,0x4f,
# 0xe4,0xcc,0x24,0xd,0x12,0x87,0x35,0x85,0x8e,0x6f,0xc6,0x13,0x9a,0xd3,0xfc,0xe7,0x8,0xac,
# 0xb7,0xe9,0xb0,0xe8,0x41,0xaa,0x55,0x53,0xc2,0x42,0xbc,0xe6,0xf,0x8a,0x86,0xa8,0xcf,0x84,
# 0xc5,0x48,0x74,0x36,0x7,0xeb,0x88,0x51,0xf6,0x7f,0x57,0x5,0x63,0x3e,0xfe,0xb8,0xc9,0xf5,
# 0xaf,0xdf,0xea,0x82,0x44,0xf9,0xcd,0x6,0xba,0x30,0x47,0x40,0xde,0xfd,0x1c,0x7c,0x11,0x5c,
# 0x2,0x31,0x2c,0x9c,0x5f,0x46,0x27,0xc4,0x83,0x73,0x16,0x90,0x20,0x76,0x7b,0xf2,0xe3,0xf3,
# 0x77,0x52,0x80,0x25,0x9,0x26,0x3f,0xc7,0x18,0x1b,0xa3,0xff,0xfb,0xcb,0xa9,0x8c,0x54,0x7a,
# 0x68,0xb4,0x70,0x4b,0xe2,0x49,0x22,0x7e,0xa5,0xb6,0x81,0x9d,0x4e,0x67,0xf1,0xa7,0x3c,0xd9,
# 0x94,0xef,0x32,0x6b,0x1f,0xb1,0x60,0xb9,0x64,0x59,0x1,0xb3,0x7d,0xe0,0x6c,0xad,0x97,0x19,
# 0xb5,0x3a,0xf4,0xd8,0x8d,0x98,0x3,0x93,0x1a,0xdc,0x1e,0x4a,0xc0,0x5a,0xe5,0xd1,0x3d,0x14,
# 0xc8,0x79,0xbd,0x43,0xdb,0x69,0xd2,0x61,0x95,0x9e,0x21,0x45,0x89,0x2b,0xab,0x29,0xa2,0x8b,
# 0x2e,0xd4,0xe,0x62,0xca,0x28,0xda,0x5b,0x72,0x8f,0x99,0x75,0xee,0x78,0xc,0x71,0xbf,0xdd,
# 0xce,0x92,0x6a,0xb2]
def getSboxK(key):
    Sbox = [0xD7, 0xDF, 0x02, 0xD4, 0xFE, 0x6F, 0x53, 0x3C, 0x25, 0x6C, 0x99, 0x97, 0x06, 0x56, 0x8F, 0xDE, 0x40, 0x11,
            0x64, 0x07, 0x36, 0x15, 0x70, 0xCA, 0x18, 0x17, 0x7D, 0x6A, 0xDB, 0x13, 0x30, 0x37, 0x29, 0x60, 0xE1, 0x23,
            0x28, 0x8A, 0x50, 0x8C, 0xAC, 0x2F, 0x88, 0x20, 0x27, 0x0F, 0x7C, 0x52, 0xA2, 0xAB, 0xFC, 0xA1, 0xCC, 0x21,
            0x14, 0x1F, 0xC2, 0xB2, 0x8B, 0x2C, 0xB0, 0x3A, 0x66, 0x46, 0x3D, 0xBB, 0x42, 0xA5, 0x0C, 0x75, 0x22, 0xD8,
            0xC3, 0x76, 0x1E, 0x83, 0x74, 0xF0, 0xF6, 0x1C, 0x26, 0xD1, 0x4F, 0x0B, 0xFF, 0x4C, 0x4D, 0xC1, 0x87, 0x03,
            0x5A, 0xEE, 0xA4, 0x5D, 0x9E, 0xF4, 0xC8, 0x0D, 0x62, 0x63, 0x3E, 0x44, 0x7B, 0xA3, 0x68, 0x32, 0x1B, 0xAA,
            0x2D, 0x05, 0xF3, 0xF7, 0x16, 0x61, 0x94, 0xE0, 0xD0, 0xD3, 0x98, 0x69, 0x78, 0xE9, 0x0A, 0x65, 0x91, 0x8E,
            0x35, 0x85, 0x7A, 0x51, 0x86, 0x10, 0x3F, 0x7F, 0x82, 0xDD, 0xB5, 0x1A, 0x95, 0xE7, 0x43, 0xFD, 0x9B, 0x24,
            0x45, 0xEF, 0x92, 0x5C, 0xE4, 0x96, 0xA9, 0x9C, 0x55, 0x89, 0x9A, 0xEA, 0xF9, 0x90, 0x5F, 0xB8, 0x04, 0x84,
            0xCF, 0x67, 0x93, 0x00, 0xA6, 0x39, 0xA8, 0x4E, 0x59, 0x31, 0x6B, 0xAD, 0x5E, 0x5B, 0x77, 0xB1, 0x54, 0xDC,
            0x38, 0x41, 0xB6, 0x47, 0x9F, 0x73, 0xBA, 0xF8, 0xAE, 0xC4, 0xBE, 0x34, 0x01, 0x4B, 0x2A, 0x8D, 0xBD, 0xC5,
            0xC6, 0xE8, 0xAF, 0xC9, 0xF5, 0xCB, 0xFB, 0xCD, 0x79, 0xCE, 0x12, 0x71, 0xD2, 0xFA, 0x09, 0xD5, 0xBC, 0x58,
            0x19, 0x80, 0xDA, 0x49, 0x1D, 0xE6, 0x2E, 0xE3, 0x7E, 0xB7, 0x3B, 0xB3, 0xA0, 0xB9, 0xE5, 0x57, 0x6E, 0xD9,
            0x08, 0xEB, 0xC7, 0xED, 0x81, 0xF1, 0xF2, 0xBF, 0xC0, 0xA7, 0x4A, 0xD6, 0x2B, 0xB4, 0x72, 0x9D, 0x0E, 0x6D,
            0xEC, 0x48, 0xE2, 0x33]

    ix = ord(key[0]) - 0x29
    Sbox[0] = Sbox[ix]
    Sbox[ix] = 0xd7
    sboxpos = 1

    while sboxpos < 256:
        value = Sbox[sboxpos]
        ix = (ix + ord(key[sboxpos]) + value)%256
        Sbox[sboxpos] = Sbox[ix]
        Sbox[ix] = value
        sboxpos += 1

    return Sbox

# byte转int(考虑到byte可能会有超出范围的情况)
# 取正
def byteToInteger(b):
	return 0xff & b

# 根据伪代码得出
def getNewBase64Old(password,tbox,rc4key4):
    app_password = password # 文本框输入的密码
    app_password_length = len(app_password)
    app_password_length_loc = app_password_length

    b64_salt_size = ord(rc4key4[3])

    app_password_tmp = math.floor(app_password_length/3)
    pwd_b64_bitlen = 8 * (3 + 3 * app_password_tmp)
    new_base64_length = math.floor(b64_salt_size + pwd_b64_bitlen/6)
    pwdsaltstr = ""

    new_base64 = [0x00] * 256


    if app_password_length_loc > 0:
        txi = 0
        pwd_idx = 0
        txj = 0
        v44 = b64_salt_size

        # 12345678 加密后 [76 6C 62 2D 22  3C 6E 30 36 77 6B 34]
        # loc_9A8
        while pwd_idx < app_password_length_loc:
            txi = (txi + 1)%256
            tx = tbox[txi]
            txj = (txj + tx) % 256
            tbox[txi] = tbox[txj]
            tbox[txj] = tx
            Rc4_T = tbox[txi]
            tboxIndex = byteToInteger( tx + Rc4_T )
            needTodoBase64 = byteToInteger( tbox[tboxIndex] ^ ord(app_password[pwd_idx]) )

            if pwd_idx == 0:
                # A0E
                new_base64_index = v44 + pwd_idx
                base64table_index = needTodoBase64>>2
                base64table_value = ord(base64table[base64table_index])
                base64table_tmp = base64table_value^7
                new_base64[new_base64_index] = base64table_tmp
                # 下面的会在下一轮加密的时候被替换掉
                needbaser64_tmp = 16 * needTodoBase64
                needbaser64_tmp2 = needbaser64_tmp & 0x30
                new_base64[new_base64_index+1] = needbaser64_tmp2

            else:
                pwdtem = pwd_idx%3
                if pwdtem == 0:
                    new_base64_index = v44 + pwd_idx
                    base64table_index = needTodoBase64 >> 2
                    base64table_value = ord(base64table[base64table_index])
                    base64table_tmp = base64table_value ^ 7
                    new_base64[new_base64_index] = base64table_tmp
                    # 下面的会在下一轮加密的时候被替换掉
                    needbaser64_tmp = 16 * needTodoBase64
                    needbaser64_tmp2 = needbaser64_tmp & 0x30
                    new_base64[new_base64_index + 1] = needbaser64_tmp2
                elif pwdtem == 1:
                    new_base64_index = v44 + pwd_idx
                    base64table_index_temp2 = new_base64[new_base64_index]
                    base64table_index_temp = needTodoBase64 >> 4
                    base64table_index = base64table_index_temp + base64table_index_temp2
                    new_base64[new_base64_index] = ord(base64table[base64table_index])
                    # 下面的会在下一轮加密的时候被替换掉
                    needbaser64_tmp = needTodoBase64 << 2
                    needbaser64_tmp2 = needbaser64_tmp & 0x3C
                    new_base64[new_base64_index + 1] = needbaser64_tmp2
                    pwd_idx_tem = pwd_idx+1
                    if pwd_idx_tem == app_password_length_loc:
                        new_base64[new_base64_index + 1] = ord(base64table[needbaser64_tmp2])
                        new_base64[new_base64_index + 2] = 0x34

                elif pwdtem == 2:
                    needbaser64_tmp2 = needTodoBase64 & 0xC0
                    new_base64_index = v44 + pwd_idx
                    v44 = v44 + 1
                    base64table_index_temp2 = new_base64[new_base64_index]
                    base64table_index_temp = needbaser64_tmp2 >> 6
                    base64table_index = base64table_index_temp2 + base64table_index_temp
                    base64table_value = ord(base64table[base64table_index])
                    # 下面的会在下一轮加密的时候被替换掉
                    base64table_tmp = base64table_value ^ 0xf
                    new_base64[new_base64_index] = base64table_tmp
                    needbaser64_tmp2 = needTodoBase64 & 0x3F
                    new_base64[new_base64_index + 1] = ord(base64table[needbaser64_tmp2])

            pwd_idx = pwd_idx + 1
    return new_base64

#优化后的代码
def getNewBase64(password,tbox,rc4key4):
    password_length = len(password)
    b64_salt_size = ord(rc4key4[3])

    # 空数组
    new_base64 = []

    if password_length <= 0:
        return

    txi = 0
    pwd_idx = 0
    txj = 0
    new_base64_tmpValue = 0

    while pwd_idx < password_length:
        txi = (txi + 1) % 256
        tx = tbox[txi]
        txj = (txj + tx) % 256
        tbox[txi] = tbox[txj]
        tbox[txj] = tx
        Rc4_T = tbox[txi]
        tboxIndex = byteToInteger(tx + Rc4_T)
        needTodoBase64 = byteToInteger(tbox[tboxIndex] ^ ord(password[pwd_idx]))

        pwdtem = pwd_idx % 3
        if pwdtem == 0:
            base64table_index = needTodoBase64 >> 2
            base64table_value = ord(base64table[base64table_index])
            base64table_tmp = base64table_value ^ 7
            new_base64.append(base64table_tmp)
            needbaser64_tmp = 16 * needTodoBase64
            new_base64_tmpValue = needbaser64_tmp & 0x30
        elif pwdtem == 1:
            base64table_index_temp = needTodoBase64 >> 4
            base64table_index = base64table_index_temp + new_base64_tmpValue
            new_base64.append(ord(base64table[base64table_index]))
            needbaser64_tmp = needTodoBase64 << 2
            new_base64_tmpValue = needbaser64_tmp & 0x3C
            pwd_idx_tem = pwd_idx + 1
            if pwd_idx_tem == password_length:
                new_base64.append(ord(base64table[new_base64_tmpValue]))
                new_base64.append(0x34)
        elif pwdtem == 2:
            needbaser64_tmp2 = needTodoBase64 & 0xC0
            b64_salt_size = b64_salt_size + 1
            base64table_index_temp = needbaser64_tmp2 >> 6
            base64table_index = new_base64_tmpValue + base64table_index_temp
            base64table_value = ord(base64table[base64table_index])
            base64table_tmp = base64table_value ^ 0xf
            new_base64.append(base64table_tmp)
            needbaser64_tmp2 = needTodoBase64 & 0x3F
            new_base64_tmpValue = ord(base64table[needbaser64_tmp2])
            new_base64.append(new_base64_tmpValue)
        pwd_idx = pwd_idx + 1
    return new_base64

def Initrc4Key():
    # Key 生成
    rc4key2 = getRc4Key2()
    rc4key3 = getRc4Key3(rc4key2)
    rc4key4 = getRc4Key4(rc4key3)
    rc4key5 = getRc4Key5(rc4key4)

    # sbox 生成
    tbox = getSboxK(rc4key5)

    # 文本框输入的密码
    # 12345678 加密后 [76 6C 62 2D 22  3C 6E 30 36 77 6B 34]
    app_password = "12345678"

    new_base64 = getNewBase64(app_password,tbox,rc4key4)
    print(new_base64)

    new_base64_length = len(new_base64)

    retn = 1
    for i in range(new_base64_length):
        if ord(encode_flag[i]) != new_base64[i]:
            retn = 0
            break

    return retn


# app_password = "fu0kzHp2aqtZAuY6" 正确结果
print(Initrc4Key())







# def base64decode():
#     encode_flag1 = []
#     for i in range(len(encode_flag)):
#         if i % 4 == 0:
#             bit = 7
#         elif i % 4 == 2 and encode_flag[i] != ';':
#             bit = 0xf
#         else:
#             bit = 0
#         encode_flag1.append(chr(ord(encode_flag[i])^bit))
#     encode_flag2 = ''.join(encode_flag1).translate(''.maketrans(base64table, std_base64table))
#     return base64.b64decode(encode_flag2)
#
# def rc4decrypt(s,sbox):
#     i = 0
#     j = 0
#     ss = []
#     asciidata = []
#     for k in range(len(s)):
#         i = (i + 1) % 256
#         j = (j + sbox[i]) % 256
#         sbox[i], sbox[j] = sbox[j], sbox[i]
#         index = (sbox[i] + sbox[j]) % 256
#         card = s[k] ^ sbox[index]
#         asciidata.append(card)
#         ss.append(chr(card))
#     print(''.join(ss))
#     return ss
# std_base64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
# base64table = "!:#$%&()+-*/`~_[]{}?<>,.@^abcdefghijklmnopqrstuvwxyz0123456789\\';"
# sbox = [0xf0,0x37,0xe1,0x9b,0x2a,0x15,0x17,0x9f,0xd7,0x58,0x4d,0x6e,0x33,0xa0,0x39,0xae,0x4,0xd0,0xbe,0xed,0xf8,0x66,0x5e,0x0,0xd6,0x91,0x2f,0xc3,0x10,0x4c,0xf7,0xa6,0xc1,0xec,0x6d,0xb,0x50,0x65,0xbb,0x34,0xfa,0xa4,0x2d,0x3b,0x23,0xa1,0x96,0xd5,0x1d,0x38,0x56,0xa,0x5d,0x4f,0xe4,0xcc,0x24,0xd,0x12,0x87,0x35,0x85,0x8e,0x6f,0xc6,0x13,0x9a,0xd3,0xfc,0xe7,0x8,0xac,0xb7,0xe9,0xb0,0xe8,0x41,0xaa,0x55,0x53,0xc2,0x42,0xbc,0xe6,0xf,0x8a,0x86,0xa8,0xcf,0x84,0xc5,0x48,0x74,0x36,0x7,0xeb,0x88,0x51,0xf6,0x7f,0x57,0x5,0x63,0x3e,0xfe,0xb8,0xc9,0xf5,0xaf,0xdf,0xea,0x82,0x44,0xf9,0xcd,0x6,0xba,0x30,0x47,0x40,0xde,0xfd,0x1c,0x7c,0x11,0x5c,0x2,0x31,0x2c,0x9c,0x5f,0x46,0x27,0xc4,0x83,0x73,0x16,0x90,0x20,0x76,0x7b,0xf2,0xe3,0xf3,0x77,0x52,0x80,0x25,0x9,0x26,0x3f,0xc7,0x18,0x1b,0xa3,0xff,0xfb,0xcb,0xa9,0x8c,0x54,0x7a,0x68,0xb4,0x70,0x4b,0xe2,0x49,0x22,0x7e,0xa5,0xb6,0x81,0x9d,0x4e,0x67,0xf1,0xa7,0x3c,0xd9,0x94,0xef,0x32,0x6b,0x1f,0xb1,0x60,0xb9,0x64,0x59,0x1,0xb3,0x7d,0xe0,0x6c,0xad,0x97,0x19,0xb5,0x3a,0xf4,0xd8,0x8d,0x98,0x3,0x93,0x1a,0xdc,0x1e,0x4a,0xc0,0x5a,0xe5,0xd1,0x3d,0x14,0xc8,0x79,0xbd,0x43,0xdb,0x69,0xd2,0x61,0x95,0x9e,0x21,0x45,0x89,0x2b,0xab,0x29,0xa2,0x8b,0x2e,0xd4,0xe,0x62,0xca,0x28,0xda,0x5b,0x72,0x8f,0x99,0x75,0xee,0x78,0xc,0x71,0xbf,0xdd,0xce,0x92,0x6a,0xb2]
# encode_flag = " {9*8ga*l!Tn?@#fj'j$\g;;"
# def base64decode():
#     encode_flag1 = []
#     for i in range(len(encode_flag)):
#         if i % 4 == 0:
#             bit = 7
#         elif i % 4 == 2 and encode_flag[i] != ';':
#             bit = 0xf
#         else:
#             bit = 0
#         encode_flag1.append(chr(ord(encode_flag[i])^bit))
#     encode_flag2 = ''.join(encode_flag1).translate(''.maketrans(base64table, std_base64table))
#     return base64.b64decode(encode_flag2)
# def rc4decrypt(s):
#     i = 0
#     j = 0
#     ss = []
#     for k in range(len(s)):
#         i = (i + 1) % 256
#         j = (j + sbox[i]) % 256
#         sbox[i], sbox[j] = sbox[j], sbox[i]
#         index = (sbox[i] + sbox[j]) % 256
#         ss.append(chr(s[k] ^ sbox[index]))
#     print(''.join(ss))
# print(rc4decrypt(base64decode()))





# table="!:#$%&()+-*/`~_[]{}?<>,.@^abcdefghijklmnopqrstuvwxyz0123456789\\'"
# r="\x20{9*8ga*l!Tn?@#fj'j$\\g;;"
# s = ""
# for i in range(6):
#     s += chr(ord(r[i*4])^7)
#     s += chr(ord(r[i*4+1]))
#     s += chr(ord(r[i*4+2])^0xf)
#     s += chr(ord(r[i*4+3]))
#
# def mydecodeb64(enc,padding):
#     enc=enc.replace(padding,"")
#     x="".join(map(lambda x:bin(table.index(x))[2:].zfill(6),enc))
#     for ap in range(8-(len(x)%8)):
#         x+='0'
#     plain=[]
#     for i in range((len(x))/8):
#         plain.append(chr(eval('0b'+x[i*8:(i+1)*8])))
#     return "".join(plain).replace("\x00","")
# s_box = [0xF0,0x37,0xE1,0x9B,0x2A,0x15,0x17,0x9F,0xD7,0x58,0x4D,0x6E,0x33,0xA0,0x39,0xAE,0x04,0xD0,0xBE,0xED,0xF8,0x66,0x5E,0x00,0xD6,0x91,0x2F,0xC3,0x10,0x4C,0xF7,0xA6,0xC1,0xEC,0x6D,0x0B,0x50,0x65,0xBB,0x34,0xFA,0xA4,0x2D,0x3B,0x23,0xA1,0x96,0xD5,0x1D,0x38,0x56,0x0A,0x5D,0x4F,0xE4,0xCC,0x24,0x0D,0x12,0x87,0x35,0x85,0x8E,0x6F,0xC6,0x13,0x9A,0xD3,0xFC,0xE7,0x08,0xAC,0xB7,0xE9,0xB0,0xE8,0x41,0xAA,0x55,0x53,0xC2,0x42,0xBC,0xE6,0x0F,0x8A,0x86,0xA8,0xCF,0x84,0xC5,0x48,0x74,0x36,0x07,0xEB,0x88,0x51,0xF6,0x7F,0x57,0x05,0x63,0x3E,0xFE,0xB8,0xC9,0xF5,0xAF,0xDF,0xEA,0x82,0x44,0xF9,0xCD,0x06,0xBA,0x30,0x47,0x40,0xDE,0xFD,0x1C,0x7C,0x11,0x5C,0x02,0x31,0x2C,0x9C,0x5F,0x46,0x27,0xC4,0x83,0x73,0x16,0x90,0x20,0x76,0x7B,0xF2,0xE3,0xF3,0x77,0x52,0x80,0x25,0x09,0x26,0x3F,0xC7,0x18,0x1B,0xA3,0xFF,0xFB,0xCB,0xA9,0x8C,0x54,0x7A,0x68,0xB4,0x70,0x4B,0xE2,0x49,0x22,0x7E,0xA5,0xB6,0x81,0x9D,0x4E,0x67,0xF1,0xA7,0x3C,0xD9,0x94,0xEF,0x32,0x6B,0x1F,0xB1,0x60,0xB9,0x64,0x59,0x01,0xB3,0x7D,0xE0,0x6C,0xAD,0x97,0x19,0xB5,0x3A,0xF4,0xD8,0x8D,0x98,0x03,0x93,0x1A,0xDC,0x1E,0x4A,0xC0,0x5A,0xE5,0xD1,0x3D,0x14,0xC8,0x79,0xBD,0x43,0xDB,0x69,0xD2,0x61,0x95,0x9E,0x21,0x45,0x89,0x2B,0xAB,0x29,0xA2,0x8B,0x2E,0xD4,0x0E,0x62,0xCA,0x28,218, 91, 114, 143, 153, 117, 238, 120, 12, 113, 191, 221, 206, 146, 106, 178]
# dec_one =  mydecodeb64(s,padding = ";")
# print len(s_box)
# v30 = 0
# v28 = 0
# flag = ""
# for i in range(16):
#     v28 = (v28+1)%256
#     v35 = s_box[v28]
#     v30 = (v30+v35)%256
#     s_box[v28] = s_box[v30]
#     s_box[v30] = v35
#     v17 = s_box[v28]
#     index = (v35+v17)%256
#     flag+=chr(s_box[index]^ord(dec_one[i]))
# print flag



# array1 = [0x20, 0x7B, 0x39, 0x2A, 0x38, 0x67, 0x61, 0x2A,
#           0x6C, 0x21, 0x54, 0x6E, 0x3F, 0x40, 0x23, 0x66,
#           0x6A, 0x27, 0x6A, 0x24, 0x5C, 0x67, 0x3B, 0x3B]
# # 0x20 0x7B 0x39 0x2A 0x38 0x67 0x61 0x2A
# # 0x6C 0x21 0x54 0x6E 0x3F 0x40 0x23 0x66
# # 0x6A 0x27 0x6A 0x24 0x5C 0x67 0x3B 0x3B
#
# array = [0x21, 0x3A, 0x23, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2B, 0x2D, 0x2A, 0x2F, 0x60, 0x7E, 0x5F, 0x5B,
#          0x5D, 0x7B, 0x7D, 0x3F, 0x3C, 0x3E, 0x2C, 0x2E, 0x40, 0x5E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
#          0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
#          0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x5C, 0x27,
#          0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
#
# mm = [0x9b, 0x6b, 0xba, 0x25, 0x73, 0x82, 0xe0, 0x31, 0x86, 0x80, 0xf1, 0xc5, 0xda, 0x82, 0xda, 0x08, 0x38, 0x90]
# # mm = [0x25,0x73,0x82]
# mm2 = []
# result = []
#
# x1 = 0
# x2 = 0
# x3 = 0
# for i in range(0, 5):
#     for x1 in range(0, 128):
#         mv = mm[0 + 3 * i] ^ x1
#         if (array[mv >> 2] ^ 7) == array1[0 + 4 * i]:
#             x11 = 16 * mv & 0x30
#             for x2 in range(0, 128):
#                 mv = mm[1 + 3 * i] ^ x2
#                 if (array[x11 | mv >> 4] == array1[1 + 4 * i]):
#                     x22 = 4 * mv & 0x3C
#                     for x3 in range(0, 128):
#                         mv = mm[2 + 3 * i] ^ x3
#                         if ((array[x22 | (mv & 0xc0) >> 6]) ^ 0xf) == array1[2 + 4 * i]:
#                             if array[mv & 0x3F] == array1[3 + 4 * i]:
#                                 print chr(x1), chr(x2), chr(x3)
#
# for x1 in range(0, 128):
#     mv = 0x08 ^ x1
#     if (array[mv >> 2] ^ 7) == 0x5c:
#         print chr(x1)
#         x11 = 16 * mv & 0x30
#         if x11 == 0x67:
#             print chr(x1)



# Base64内嵌在RC4的内部
# 先线程一个RC4加密后的字符
# 后面用这个字符进行Base64的解码操作
# Base64魔改的算法：
# 1：Base64 字典被替换
# 2：Base最后以为“=”会被替换成“;”
# 3: 对特定字符进行异或操作.每4个字符中第0个与0x6异或，第0个与0xF异或
# switch (i%4){
# 	case 0:
# 		base64char = (char) (iAscii ^0x07);
# 		break;
#     case 2:
#         base64char = (char) (iAscii ^0xF);
#         break;
#     default:
#         base64char =encodeChars[i];
# }


# 7
# // test_main.cpp
# // to
# compile: cl.exe
# test_main.cpp
# // to
# run: test_main.exe
#
# # include <windows.h>
# # include <stdio.h>
#
# unsigned
# char
# g_gidstr[] = "650f909c-7217-3647-9331-c82df8b98e98";
# char
# vs16[] = "dbeafc2409715836";
# unsigned
# char
# g_buf100[] = {
#     0xD7, 0xDF, 0x02, 0xD4, 0xFE, 0x6F, 0x53, 0x3C, 0x25, 0x6C, 0x99, 0x97, 0x06, 0x56, 0x8F, 0xDE,
#     0x40, 0x11, 0x64, 0x07, 0x36, 0x15, 0x70, 0xCA, 0x18, 0x17, 0x7D, 0x6A, 0xDB, 0x13, 0x30, 0x37,
#     0x29, 0x60, 0xE1, 0x23, 0x28, 0x8A, 0x50, 0x8C, 0xAC, 0x2F, 0x88, 0x20, 0x27, 0x0F, 0x7C, 0x52,
#     0xA2, 0xAB, 0xFC, 0xA1, 0xCC, 0x21, 0x14, 0x1F, 0xC2, 0xB2, 0x8B, 0x2C, 0xB0, 0x3A, 0x66, 0x46,
#     0x3D, 0xBB, 0x42, 0xA5, 0x0C, 0x75, 0x22, 0xD8, 0xC3, 0x76, 0x1E, 0x83, 0x74, 0xF0, 0xF6, 0x1C,
#     0x26, 0xD1, 0x4F, 0x0B, 0xFF, 0x4C, 0x4D, 0xC1, 0x87, 0x03, 0x5A, 0xEE, 0xA4, 0x5D, 0x9E, 0xF4,
#     0xC8, 0x0D, 0x62, 0x63, 0x3E, 0x44, 0x7B, 0xA3, 0x68, 0x32, 0x1B, 0xAA, 0x2D, 0x05, 0xF3, 0xF7,
#     0x16, 0x61, 0x94, 0xE0, 0xD0, 0xD3, 0x98, 0x69, 0x78, 0xE9, 0x0A, 0x65, 0x91, 0x8E, 0x35, 0x85,
#     0x7A, 0x51, 0x86, 0x10, 0x3F, 0x7F, 0x82, 0xDD, 0xB5, 0x1A, 0x95, 0xE7, 0x43, 0xFD, 0x9B, 0x24,
#     0x45, 0xEF, 0x92, 0x5C, 0xE4, 0x96, 0xA9, 0x9C, 0x55, 0x89, 0x9A, 0xEA, 0xF9, 0x90, 0x5F, 0xB8,
#     0x04, 0x84, 0xCF, 0x67, 0x93, 0x00, 0xA6, 0x39, 0xA8, 0x4E, 0x59, 0x31, 0x6B, 0xAD, 0x5E, 0x5B,
#     0x77, 0xB1, 0x54, 0xDC, 0x38, 0x41, 0xB6, 0x47, 0x9F, 0x73, 0xBA, 0xF8, 0xAE, 0xC4, 0xBE, 0x34,
#     0x01, 0x4B, 0x2A, 0x8D, 0xBD, 0xC5, 0xC6, 0xE8, 0xAF, 0xC9, 0xF5, 0xCB, 0xFB, 0xCD, 0x79, 0xCE,
#     0x12, 0x71, 0xD2, 0xFA, 0x09, 0xD5, 0xBC, 0x58, 0x19, 0x80, 0xDA, 0x49, 0x1D, 0xE6, 0x2E, 0xE3,
#     0x7E, 0xB7, 0x3B, 0xB3, 0xA0, 0xB9, 0xE5, 0x57, 0x6E, 0xD9, 0x08, 0xEB, 0xC7, 0xED, 0x81, 0xF1,
#     0xF2, 0xBF, 0xC0, 0xA7, 0x4A, 0xD6, 0x2B, 0xB4, 0x72, 0x9D, 0x0E, 0x6D, 0xEC, 0x48, 0xE2, 0x33
# };
# unsigned
# char
# ref100[] = {
#     0xF0, 0x37, 0xE1, 0x9B, 0x2A, 0x15, 0x17, 0x9F, 0xD7, 0x58, 0x4D, 0x6E, 0x33, 0xA0, 0x39, 0xAE,
#     0x04, 0xD0, 0xBE, 0xED, 0xF8, 0x66, 0x5E, 0x00, 0xD6, 0x91, 0x2F, 0xC3, 0x10, 0x4C, 0xF7, 0xA6,
#     0xC1, 0xEC, 0x6D, 0x0B, 0x50, 0x65, 0xBB, 0x34, 0xFA, 0xA4, 0x2D, 0x3B, 0x23, 0xA1, 0x96, 0xD5,
#     0x1D, 0x38, 0x56, 0x0A, 0x5D, 0x4F, 0xE4, 0xCC, 0x24, 0x0D, 0x12, 0x87, 0x35, 0x85, 0x8E, 0x6F,
#     0xC6, 0x13, 0x9A, 0xD3, 0xFC, 0xE7, 0x08, 0xAC, 0xB7, 0xE9, 0xB0, 0xE8, 0x41, 0xAA, 0x55, 0x53,
#     0xC2, 0x42, 0xBC, 0xE6, 0x0F, 0x8A, 0x86, 0xA8, 0xCF, 0x84, 0xC5, 0x48, 0x74, 0x36, 0x07, 0xEB,
#     0x88, 0x51, 0xF6, 0x7F, 0x57, 0x05, 0x63, 0x3E, 0xFE, 0xB8, 0xC9, 0xF5, 0xAF, 0xDF, 0xEA, 0x82,
#     0x44, 0xF9, 0xCD, 0x06, 0xBA, 0x30, 0x47, 0x40, 0xDE, 0xFD, 0x1C, 0x7C, 0x11, 0x5C, 0x02, 0x31,
#     0x2C, 0x9C, 0x5F, 0x46, 0x27, 0xC4, 0x83, 0x73, 0x16, 0x90, 0x20, 0x76, 0x7B, 0xF2, 0xE3, 0xF3,
#     0x77, 0x52, 0x80, 0x25, 0x09, 0x26, 0x3F, 0xC7, 0x18, 0x1B, 0xA3, 0xFF, 0xFB, 0xCB, 0xA9, 0x8C,
#     0x54, 0x7A, 0x68, 0xB4, 0x70, 0x4B, 0xE2, 0x49, 0x22, 0x7E, 0xA5, 0xB6, 0x81, 0x9D, 0x4E, 0x67,
#     0xF1, 0xA7, 0x3C, 0xD9, 0x94, 0xEF, 0x32, 0x6B, 0x1F, 0xB1, 0x60, 0xB9, 0x64, 0x59, 0x01, 0xB3,
#     0x7D, 0xE0, 0x6C, 0xAD, 0x97, 0x19, 0xB5, 0x3A, 0xF4, 0xD8, 0x8D, 0x98, 0x03, 0x93, 0x1A, 0xDC,
#     0x1E, 0x4A, 0xC0, 0x5A, 0xE5, 0xD1, 0x3D, 0x14, 0xC8, 0x79, 0xBD, 0x43, 0xDB, 0x69, 0xD2, 0x61,
#     0x95, 0x9E, 0x21, 0x45, 0x89, 0x2B, 0xAB, 0x29, 0xA2, 0x8B, 0x2E, 0xD4, 0x0E, 0x62, 0xCA, 0x28,
#     0xDA, 0x5B, 0x72, 0x8F, 0x99, 0x75, 0xEE, 0x78, 0x0C, 0x71, 0xBF, 0xDD, 0xCE, 0x92, 0x6A, 0xB2
# };
#
# // unsigned
# char
# b64bin[18] = {0xF9, 0x1E, 0x8A, 0x4E, 0x09, 0xCA, 0x90, 0x03, 0xE7, 0xF1, 0x85, 0x9F, 0x9B, 0xE7, 0x83, 0x3E, 0x0E,
#               0x3F};
# // unsigned
# char
# b64bin[16] = {0xF9, 0x1E, 0x8A, 0x4E, 0x09, 0xCA, 0x90, 0x03, 0xE7, 0xF1, 0x85, 0x9F, 0x9B, 0xE7, 0x83, 0x5E};
# unsigned
# char
# b64bin[16] = {0xFD, 0x1E, 0x8A, 0x4E, 0x09, 0xCA, 0x90, 0x03, 0xE7, 0xF1, 0x85, 0x9F, 0x9B, 0xF7, 0x83, 0x3E};
#
# unsigned
# char
# gpwd[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#
# void
# test1()
# {
#     unsigned
# char * gidstr = & g_gidstr[0];
# unsigned
# char * gidbuf1 = NULL;
# unsigned
# char * gidbuf2_nosplit = NULL;
# unsigned
# char * gidbuf3 = NULL;
# unsigned
# char * v7, v14, *v15, pwdch, tx;
# char * v16, *pbuf2;
# int
# guidlen, gidbuf2_nosplit_len, v6, v8, v9, v11, v12, v13, ix, v21, v22, txi, txj;
# unsigned
# int
# v1, i;
# char
# loc_buf100[0x100];
# char
# buf100_2[0x100];
# guidlen = strlen((const char *)
# gidstr);
# gidbuf1 = (unsigned char *)
# malloc(guidlen);
# gidbuf2_nosplit = (unsigned char *)
# malloc(guidlen);
# gidbuf3 = (unsigned char *)
# malloc(guidlen);
# memset(gidbuf1, 0, guidlen);
# memset(gidbuf2_nosplit, 0, guidlen);
# memset(gidbuf3, 0, guidlen);
#
# if (guidlen)
# {
#     gidbuf2_nosplit_len = 0;
# v6 = guidlen;
# v7 = gidstr;
# do
# {
#     v8 = (unsigned char) * v7 + +;
# if (v8 != '-')
# gidbuf2_nosplit[gidbuf2_nosplit_len + +] = v8;
# --v6;
# }
# while (v6);
# }
# printf("gidbuf2 len: %d\tbytes:[%s]\n", gidbuf2_nosplit_len, gidbuf2_nosplit);
# // gidbuf2
# len: 32
# bytes: [650f909c721736479331c82df8b98e98]
# if (gidbuf2_nosplit_len > 1)
# {
# v9 = gidbuf2_nosplit_len - 1;
# v1 = -8;
# v11 = 0;
# v12 = 0;
# do
# {
# if ((v11 | (v1 >> 2)) > 3)
# {
#     v13 = v12;
# }
# else {
#     v13 = v12 + 1;
# gidbuf1[v12] = '-';
# }
# v14 = gidbuf2_nosplit[v9 - -];
# v11 += 0x40000000;
# gidbuf1[v13] = v14;
# ++v1;
# v12 = v13 + 1;
# }while (v9 != -1);
# }
# printf("gidbuf1 len: %d %d\tbytes:[%s]\n", v13, v12, gidbuf1);
# // gidbuf1
# len: 35
# bytes: [89e89b8f - d28c - 1339 - 7463 - 7127c909f056]
# if (v13 >= 0)
# {
# v15 = gidbuf3;
# do
# {
#     v16 = (char *)
# gidbuf1;
# if ((unsigned char)(*v16 - 'a') <= 5u)
# {
#     v16 = & vs16[*v16 - 'a'];
# } else if ((unsigned char)(*v16 - '0') <= 9u){
# v16= & vs16[* v16-'0'];
# }
# * v15= * v16;
# v15++;
# --v12;
# ++gidbuf1;
# } while (v12 != 0);
# }
# printf("gidbuf3 len: %d\tbytes:[%s]\n", v15 - gidbuf3, gidbuf3);
# // gidbuf3
# len: 36
# bytes: [09f09b0c - ae0e - baa9 - 4f2a - 4be4e9d9cdc2]
# memcpy( & loc_buf100[0], & g_buf100[0], 0x100);
# pbuf2 = & buf100_2[0];
# i = 0;
# do
# {
# buf100_2[i + +] = gidbuf3[i % guidlen];
# }
# while (i != 256);
# //
# ix = (unsigned char)(buf100_2[0] - 41);
# loc_buf100[0] = loc_buf100[ix];
# loc_buf100[ix] = 0xd7; // -41;
# v21 = 1;
# do
# {
#     v22 = (unsigned char)
# loc_buf100[v21];
# ix = (ix + (unsigned char)buf100_2[v21]+v22) % 256;
# loc_buf100[v21 + +] = loc_buf100[ix];
# loc_buf100[ix] = v22;
# }
# while (v21 != 256);
# printf("-----------------------------------------\n");
# for (i=0;i < 0x100;i++){
#     printf("%02X ", (unsigned char)loc_buf100[i]);
# if ((i+1) % 16 == 0){
# printf("\n");
# }
# }
# printf("-----------------------------------------\n");
# / *
# 0xF0, 0x37, 0xE1, 0x9B, 0x2A, 0x15, 0x17, 0x9F, 0xD7, 0x58, 0x4D, 0x6E, 0x33, 0xA0, 0x39, 0xAE,
# 0x04, 0xD0, 0xBE, 0xED, 0xF8, 0x66, 0x5E, 0x00, 0xD6, 0x91, 0x2F, 0xC3, 0x10, 0x4C, 0xF7, 0xA6,
# 0xC1, 0xEC, 0x6D, 0x0B, 0x50, 0x65, 0xBB, 0x34, 0xFA, 0xA4, 0x2D, 0x3B, 0x23, 0xA1, 0x96, 0xD5,
# 0x1D, 0x38, 0x56, 0x0A, 0x5D, 0x4F, 0xE4, 0xCC, 0x24, 0x0D, 0x12, 0x87, 0x35, 0x85, 0x8E, 0x6F,
# 0xC6, 0x13, 0x9A, 0xD3, 0xFC, 0xE7, 0x08, 0xAC, 0xB7, 0xE9, 0xB0, 0xE8, 0x41, 0xAA, 0x55, 0x53,
# 0xC2, 0x42, 0xBC, 0xE6, 0x0F, 0x8A, 0x86, 0xA8, 0xCF, 0x84, 0xC5, 0x48, 0x74, 0x36, 0x07, 0xEB,
# 0x88, 0x51, 0xF6, 0x7F, 0x57, 0x05, 0x63, 0x3E, 0xFE, 0xB8, 0xC9, 0xF5, 0xAF, 0xDF, 0xEA, 0x82,
# 0x44, 0xF9, 0xCD, 0x06, 0xBA, 0x30, 0x47, 0x40, 0xDE, 0xFD, 0x1C, 0x7C, 0x11, 0x5C, 0x02, 0x31,
# 0x2C, 0x9C, 0x5F, 0x46, 0x27, 0xC4, 0x83, 0x73, 0x16, 0x90, 0x20, 0x76, 0x7B, 0xF2, 0xE3, 0xF3,
# 0x77, 0x52, 0x80, 0x25, 0x09, 0x26, 0x3F, 0xC7, 0x18, 0x1B, 0xA3, 0xFF, 0xFB, 0xCB, 0xA9, 0x8C,
# 0x54, 0x7A, 0x68, 0xB4, 0x70, 0x4B, 0xE2, 0x49, 0x22, 0x7E, 0xA5, 0xB6, 0x81, 0x9D, 0x4E, 0x67,
# 0xF1, 0xA7, 0x3C, 0xD9, 0x94, 0xEF, 0x32, 0x6B, 0x1F, 0xB1, 0x60, 0xB9, 0x64, 0x59, 0x01, 0xB3,
# 0x7D, 0xE0, 0x6C, 0xAD, 0x97, 0x19, 0xB5, 0x3A, 0xF4, 0xD8, 0x8D, 0x98, 0x03, 0x93, 0x1A, 0xDC,
# 0x1E, 0x4A, 0xC0, 0x5A, 0xE5, 0xD1, 0x3D, 0x14, 0xC8, 0x79, 0xBD, 0x43, 0xDB, 0x69, 0xD2, 0x61,
# 0x95, 0x9E, 0x21, 0x45, 0x89, 0x2B, 0xAB, 0x29, 0xA2, 0x8B, 0x2E, 0xD4, 0x0E, 0x62, 0xCA, 0x28,
# 0xDA, 0x5B, 0x72, 0x8F, 0x99, 0x75, 0xEE, 0x78, 0x0C, 0x71, 0xBF, 0xDD, 0xCE, 0x92, 0x6A, 0xB2,
# * /
# txi = 0;
# i = 0;
# txj = 0;
# // v44 = b64_salt_size;
# do
# {
#     txi = (txi + 1) % 256;
# tx = (unsigned char)
# loc_buf100[txi];
# txj = (txj + tx) % 256;
# loc_buf100[txi] = loc_buf100[txj];
# loc_buf100[txj] = tx;
# pwdch = loc_buf100[(unsigned char)(tx + loc_buf100[txi])] ^ b64bin[i];
# gpwd[i] = pwdch;
# ++i;
# }
# while (i < 16);
# printf("-----------------------------------------\n");
# txi = 0;
# i = 0;
# txj = 0;
# // v44 = b64_salt_size;
# do
# {
#     txi = (txi + 1) % 256;
# tx = (unsigned char)
# ref100[txi];
# txj = (txj + tx) % 256;
# ref100[txi] = ref100[txj];
# ref100[txj] = tx;
# printf("0x%02X, ", ref100[(unsigned char)(tx + ref100[txi])]);
# pwdch = ref100[(unsigned char)(tx + ref100[txi])] ^ b64bin[i];
# gpwd[i] = pwdch;
# ++i;
# }
# while (i < 16);
# printf("\ngidbuf3 len: %d\tbytes:[%s]\n", 16, gpwd);
# for (i=0;i < 20;i++){
#     printf("%02X ", (unsigned char)gpwd[i]);
# }
# printf("\n");
# }
#
#
# int
# main(int
# argc, char * argv[]){
# test1();
# return 0;
# }